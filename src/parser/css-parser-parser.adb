
pragma Style_Checks (Off);
with Interfaces;
with CSS.Parser.Parser_Goto;
with CSS.Parser.Parser_Tokens; 
with CSS.Parser.Parser_Shift_Reduce;
with CSS.Parser.Lexer_IO;
with CSS.Parser.Lexer;
with CSS.Parser.Lexer_Dfa;
with CSS.Core.Selectors;
with CSS.Core.Styles;
with CSS.Core.Medias;
with Ada.Text_IO;
package body CSS.Parser.Parser is

   use Ada;
   use CSS.Parser.Lexer;
   use CSS.Core.Selectors;
   use CSS.Parser.Lexer_Dfa;
   use type Ada.Text_IO.Count;
   use type Interfaces.Unsigned_64;

   procedure yyparse;

   procedure yyerror (Message : in String := "syntax error");

   Document      : CSS.Core.Sheets.CSSStylesheet_Access;
   Current_Page  : CSS.Core.Styles.CSSPageRule_Access;
   Current_Rule  : CSS.Core.Styles.CSSStyleRule_Access;
   Current_Media : CSS.Core.Medias.CSSMediaRule_Access;

   procedure yyerror (Message : in String := "syntax error") is
      pragma Unreferenced (Message);
   begin
      error_count := error_count + 1;
      Error (CSS.Parser.Lexer_Dfa.yylineno, CSS.Parser.Lexer_Dfa.yylinecol, Message);
   end yyerror;

   function Parse (Content  : in String;
                   Document : in CSS.Core.Sheets.CSSStylesheet_Access) return Integer is
   begin
      Error_Count := 0;
      CSS.Parser.Lexer_Dfa.yylineno  := 1;
      CSS.Parser.Lexer_Dfa.yylinecol := 1;
      CSS.Parser.Lexer_IO.Open_Input (Content);
      CSS.Parser.Parser.Document := Document;
      Current_Rule := null;
      Current_Media := null;
      Current_Page := null;
      yyparse;
      Current_Rule := null;
      Current_Media := null;
      Current_Page := null;
      CSS.Parser.Parser.Document := null;
      CSS.Parser.Lexer_IO.Close_Input;
      Parser_Tokens.yylval := EMPTY;
      return Error_Count;

   exception
      when others =>
         CSS.Parser.Parser.Document := null;
         CSS.Parser.Lexer_IO.Close_Input;
         Parser_Tokens.yylval := EMPTY;
         raise;

   end Parse;

--  Warning: This file is automatically generated by AYACC.
--           It is useless to modify it. Change the ".Y" & ".L" files instead.


procedure YYParse is

   -- Rename User Defined Packages to Internal Names.
    package yy_goto_tables         renames
      CSS.Parser.Parser_Goto;
    package yy_shift_reduce_tables renames
      CSS.Parser.Parser_Shift_Reduce;
    package yy_tokens              renames
      CSS.Parser.Parser_Tokens;

   use yy_tokens, yy_goto_tables, yy_shift_reduce_tables;

   procedure yyerrok;
   procedure yyclearin;


   package yy is

       -- the size of the value and state stacks
       --  Affects error 'Stack size exceeded on state_stack'
       stack_size : constant Natural :=  256;

       -- subtype rule         is natural;
       subtype parse_state  is natural;
       -- subtype nonterminal  is integer;

       -- encryption constants
       default           : constant := -1;
       first_shift_entry : constant :=  0;
       accept_code       : constant := -3001;
       error_code        : constant := -3000;

       -- stack data used by the parser
       tos                : natural := 0;
       value_stack        : array(0..stack_size) of yy_tokens.yystype;
       state_stack        : array(0..stack_size) of parse_state;

       -- current input symbol and action the parser is on
       action             : integer;
       rule_id            : rule;
       input_symbol       : yy_tokens.token:= Error;


       -- error recovery flag
       error_flag : natural := 0;
          -- indicates  3 - (number of valid shifts after an error occurs)

       look_ahead : boolean := true;
       index      : integer;

       -- Is Debugging option on or off
        DEBUG : constant boolean := FALSE;

    end yy;


    function goto_state
      (state : yy.parse_state;
       sym   : nonterminal) return yy.parse_state;

    function parse_action
      (state : yy.parse_state;
       t     : yy_tokens.token) return integer;

    pragma inline(goto_state, parse_action);


    function goto_state(state : yy.parse_state;
                        sym   : nonterminal) return yy.parse_state is
        index : integer;
    begin
        index := goto_offset(state);
        while  integer(goto_matrix(index).nonterm) /= sym loop
            index := index + 1;
        end loop;
        return integer(goto_matrix(index).newstate);
    end goto_state;


    function parse_action(state : yy.parse_state;
                          t     : yy_tokens.token) return integer is
        index      : integer;
        tok_pos    : integer;
        default    : constant integer := -1;
    begin
        tok_pos := yy_tokens.token'pos(t);
        index   := shift_reduce_offset(state);
        while integer(shift_reduce_matrix(index).t) /= tok_pos and then
              integer(shift_reduce_matrix(index).t) /= default
        loop
            index := index + 1;
        end loop;
        return integer(shift_reduce_matrix(index).act);
    end parse_action;

-- error recovery stuff

    procedure handle_error is
      temp_action : integer;
    begin

      if yy.error_flag = 3 then -- no shift yet, clobber input.
      if yy.debug then
          text_io.put_line("  -- Ayacc.YYParse: Error Recovery Clobbers " &
                   yy_tokens.token'image(yy.input_symbol));
      end if;
        if yy.input_symbol = yy_tokens.end_of_input then  -- don't discard,
        if yy.debug then
            text_io.put_line("  -- Ayacc.YYParse: Can't discard END_OF_INPUT, quiting...");
        end if;
        raise yy_tokens.syntax_error;
        end if;

            yy.look_ahead := true;   -- get next token
        return;                  -- and try again...
    end if;

    if yy.error_flag = 0 then -- brand new error
       yyerror("Syntax Error");
    end if;

    yy.error_flag := 3;

    -- find state on stack where error is a valid shift --

    if yy.debug then
        text_io.put_line("  -- Ayacc.YYParse: Looking for state with error as valid shift");
    end if;

    loop
        if yy.debug then
          text_io.put_line("  -- Ayacc.YYParse: Examining State " &
               yy.parse_state'image(yy.state_stack(yy.tos)));
        end if;
        temp_action := parse_action(yy.state_stack(yy.tos), error);

            if temp_action >= yy.first_shift_entry then
                if yy.tos = yy.stack_size then
                    text_io.put_line("  -- Ayacc.YYParse: Stack size exceeded on state_stack");
                    raise yy_Tokens.syntax_error;
                end if;
                yy.tos := yy.tos + 1;
                yy.state_stack(yy.tos) := temp_action;
                exit;
            end if;

        Decrement_Stack_Pointer :
        begin
          yy.tos := yy.tos - 1;
        exception
          when Constraint_Error =>
            yy.tos := 0;
        end Decrement_Stack_Pointer;

        if yy.tos = 0 then
          if yy.debug then
            text_io.put_line("  -- Ayacc.YYParse: Error recovery popped entire stack, aborting...");
          end if;
          raise yy_tokens.syntax_error;
        end if;
    end loop;

    if yy.debug then
        text_io.put_line("  -- Ayacc.YYParse: Shifted error token in state " &
              yy.parse_state'image(yy.state_stack(yy.tos)));
    end if;

    end handle_error;

   -- print debugging information for a shift operation
   procedure shift_debug(state_id: yy.parse_state; lexeme: yy_tokens.token) is
   begin
       text_io.put_line("  -- Ayacc.YYParse: Shift "& yy.parse_state'image(state_id)&" on input symbol "&
               yy_tokens.token'image(lexeme) );
   end;

   -- print debugging information for a reduce operation
   procedure reduce_debug(rule_id: rule; state_id: yy.parse_state) is
   begin
       text_io.put_line("  -- Ayacc.YYParse: Reduce by rule "&rule'image(rule_id)&" goto state "&
               yy.parse_state'image(state_id));
   end;

   -- make the parser believe that 3 valid shifts have occured.
   -- used for error recovery.
   procedure yyerrok is
   begin
       yy.error_flag := 0;
   end yyerrok;

   -- called to clear input symbol that caused an error.
   procedure yyclearin is
   begin
       -- yy.input_symbol := yylex;
       yy.look_ahead := true;
   end yyclearin;


begin
    -- initialize by pushing state 0 and getting the first input symbol
    yy.state_stack(yy.tos) := 0;


    loop

        yy.index := shift_reduce_offset(yy.state_stack(yy.tos));
        if integer(shift_reduce_matrix(yy.index).t) = yy.default then
            yy.action := integer(shift_reduce_matrix(yy.index).act);
        else
            if yy.look_ahead then
                yy.look_ahead   := false;

                yy.input_symbol := yylex;
            end if;
            yy.action :=
             parse_action(yy.state_stack(yy.tos), yy.input_symbol);
        end if;


        if yy.action >= yy.first_shift_entry then  -- SHIFT

            if yy.debug then
                shift_debug(yy.action, yy.input_symbol);
            end if;

            -- Enter new state
            if yy.tos = yy.stack_size then
                text_io.put_line(" Stack size exceeded on state_stack");
                raise yy_Tokens.syntax_error;
            end if;
            yy.tos := yy.tos + 1;
            yy.state_stack(yy.tos) := yy.action;
              yy.value_stack(yy.tos) := yylval;

        if yy.error_flag > 0 then  -- indicate a valid shift
            yy.error_flag := yy.error_flag - 1;
        end if;

            -- Advance lookahead
            yy.look_ahead := true;

        elsif yy.action = yy.error_code then       -- ERROR

            handle_error;

        elsif yy.action = yy.accept_code then
            if yy.debug then
                text_io.put_line("  -- Ayacc.YYParse: Accepting Grammar...");
            end if;
            exit;

        else -- Reduce Action

            -- Convert action into a rule
            yy.rule_id  := -1 * yy.action;

            -- Execute User Action
            -- user_action(yy.rule_id);


                case yy.rule_id is

when 4 => -- #line 78
 Error (
yy.value_stack(yy.tos).Line, 
yy.value_stack(yy.tos).Column, "Invalid CSS selector component"); 

when 32 => -- #line 158
 Current_Media := null; 

when 33 => -- #line 161
 Current_Media := null; 

when 38 => -- #line 176
 Current_Rule := null; Error (yylval.Line, yylval.Column, "Media condition error"); 

when 39 => -- #line 181
 Current_Rule := null; 

when 40 => -- #line 186
 Current_Rule := null; 

when 41 => -- #line 189
 Error (
yy.value_stack(yy.tos-2).Line, 
yy.value_stack(yy.tos-2).Column, "Invalid media selection after " & To_String (
yy.value_stack(yy.tos-2)));  yyerrok; 

when 45 => -- #line 202
 Current_Rule := null; 

when 46 => -- #line 207
 Current_Rule := null; 

when 47 => -- #line 210
 Current_Rule := null; 

when 48 => -- #line 215
 Current_Rule := null; Error (
yy.value_stack(yy.tos-1).line, 
yy.value_stack(yy.tos).line, "Found @<font-face> rule"); 

when 49 => -- #line 220
 Append_Media (Current_Media, Document, 
yy.value_stack(yy.tos)); 

when 50 => -- #line 223
 Append_Media (Current_Media, Document, 
yy.value_stack(yy.tos)); 

when 53 => -- #line 234
 Set_String (
yyval, "not ", 
yy.value_stack(yy.tos-4).Line, 
yy.value_stack(yy.tos-4).Column); Append_String (
yyval, 
yy.value_stack(yy.tos-2), 
yy.value_stack(yy.tos)); 

when 54 => -- #line 237
 Set_String (
yyval, "only ", 
yy.value_stack(yy.tos-4).Line, 
yy.value_stack(yy.tos-4).Column); Append_String (
yyval, 
yy.value_stack(yy.tos-2), 
yy.value_stack(yy.tos)); 

when 55 => -- #line 240
 
yyval := 
yy.value_stack(yy.tos-2); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 56 => -- #line 245
 Set_String (
yyval, " and ", 
yy.value_stack(yy.tos-2).Line, 
yy.value_stack(yy.tos-2).Column); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 57 => -- #line 248
 Set_String (
yyval, "", yylval.Line, yylval.Column); 

when 58 => -- #line 253
 Set_String (
yyval, "not ", 
yy.value_stack(yy.tos-2).Line, 
yy.value_stack(yy.tos-2).Column); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 62 => -- #line 264
 Set_String (
yyval, "not ", 
yy.value_stack(yy.tos-2).Line, 
yy.value_stack(yy.tos-2).Column); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 63 => -- #line 267
 
yyval := 
yy.value_stack(yy.tos-1); Append_String (
yyval, " "); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 65 => -- #line 274
 
yyval := 
yy.value_stack(yy.tos-1); Append_String (
yyval, " "); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 67 => -- #line 281
 Set_String (
yyval, "and ", 
yy.value_stack(yy.tos-2).Line, 
yy.value_stack(yy.tos-2).Column); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 68 => -- #line 286
 
yyval := 
yy.value_stack(yy.tos-1); Append_String (
yyval, " "); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 70 => -- #line 293
 Set_String (
yyval, "or ", 
yy.value_stack(yy.tos-1).Line, 
yy.value_stack(yy.tos-1).Column); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 71 => -- #line 298
 Set_String (
yyval, "(", 
yy.value_stack(yy.tos-3).Line, 
yy.value_stack(yy.tos-3).Column); Append_String (
yyval, 
yy.value_stack(yy.tos-3)); Append_String (
yyval, ")"); 

when 72 => -- #line 301
 Set_String (
yyval, "(", 
yy.value_stack(yy.tos-3).Line, 
yy.value_stack(yy.tos-3).Column); Append_String (
yyval, 
yy.value_stack(yy.tos-3)); Append_String (
yyval, ")"); 

when 73 => -- #line 304
 Set_String (
yyval, "(", 
yy.value_stack(yy.tos-3).Line, 
yy.value_stack(yy.tos-3).Column); Append_String (
yyval, 
yy.value_stack(yy.tos-3)); Append_String (
yyval, ")"); 

when 74 => -- #line 307
 Error (yylval.Line, yylval.Column, "Invalid media in parens");
         Set_String (
yyval, "", yylval.Line, yylval.Column); yyerrok; 

when 75 => -- #line 313
 Set_String (
yyval, "<=", yylval.Line, yylval.Column); 

when 76 => -- #line 316
 Set_String (
yyval, ">=", yylval.Line, yylval.Column); 

when 77 => -- #line 319
 Set_String (
yyval, ">", yylval.Line, yylval.Column); 

when 78 => -- #line 322
 Set_String (
yyval, "<", yylval.Line, yylval.Column); 

when 79 => -- #line 327
 
yyval := 
yy.value_stack(yy.tos-4); Append_String (
yyval, 
yy.value_stack(yy.tos-2)); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 80 => -- #line 330
 
yyval := 
yy.value_stack(yy.tos-6); Append_String (
yyval, 
yy.value_stack(yy.tos-4)); Append_String (
yyval, 
yy.value_stack(yy.tos-2)); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 81 => -- #line 333
 
yyval := 
yy.value_stack(yy.tos-4); Append_String (
yyval, 
yy.value_stack(yy.tos-2)); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 82 => -- #line 336
 
yyval := 
yy.value_stack(yy.tos-4); Append_String (
yyval, ": "); Append_String (
yyval, 
yy.value_stack(yy.tos)); 

when 84 => -- #line 343
 
yyval := 
yy.value_stack(yy.tos); 

when 85 => -- #line 346
 
yyval := 
yy.value_stack(yy.tos); 

when 86 => -- #line 351
 Current_Page := null; 

when 87 => -- #line 354
 Current_Page := null; 

when 88 => -- #line 359
 null; 

when 89 => -- #line 362
 null; 

when 90 => -- #line 367
 Current_Page := new CSS.Core.Styles.CSSPageRule; 

when 94 => -- #line 380
 Set_Selector (
yyval, SEL_PSEUDO_ELEMENT, 
yy.value_stack(yy.tos)); 

when 95 => -- #line 385
 Append_Property (Current_Page.Style, Document, 
yy.value_stack(yy.tos-1)); 

when 96 => -- #line 388
 Append_Property (Current_Page.Style, Document, 
yy.value_stack(yy.tos-1)); 

when 97 => -- #line 393
 
yyval := 
yy.value_stack(yy.tos-1); 

when 98 => -- #line 396
 
yyval := 
yy.value_stack(yy.tos-1); 

when 99 => -- #line 401
 Set_Selector_Type (
yyval, SEL_NEXT_SIBLING, yylineno, yylinecol); 

when 100 => -- #line 404
 Set_Selector_Type (
yyval, SEL_CHILD, yylineno, yylinecol); 

when 101 => -- #line 407
 Set_Selector_Type (
yyval, SEL_FOLLOWING_SIBLING, yylineno, yylinecol); 

when 104 => -- #line 418
 Current_Rule := null; 

when 105 => -- #line 421
 Current_Rule := null; Error (
yy.value_stack(yy.tos-1).line, 
yy.value_stack(yy.tos-1).column, "Invalid CSS rule"); 

when 106 => -- #line 424
 Current_Rule := null; 

when 107 => -- #line 427
 Error (
yy.value_stack(yy.tos-2).Line, 
yy.value_stack(yy.tos-2).Column, "Syntax error in CSS rule"); 

when 108 => -- #line 432
 
yyval := 
yy.value_stack(yy.tos-1); 

when 109 => -- #line 435
 
yyval := 
yy.value_stack(yy.tos); 

when 111 => -- #line 442
 Error (
yy.value_stack(yy.tos-1).Line, 
yy.value_stack(yy.tos-1).Column, "Invalid CSS selector component"); 

when 112 => -- #line 447
 Add_Selector_List (Current_Rule, Current_Media, Document, 
yy.value_stack(yy.tos)); 

when 113 => -- #line 450
 Add_Selector_List (Current_Rule, Current_Media, Document, 
yy.value_stack(yy.tos)); 

when 114 => -- #line 455
 Add_Selector (
yy.value_stack(yy.tos-3), 
yy.value_stack(yy.tos-2), 
yy.value_stack(yy.tos-1)); 
yyval := 
yy.value_stack(yy.tos-3); 

when 115 => -- #line 458
 Add_Selector (
yy.value_stack(yy.tos-2), 
yy.value_stack(yy.tos-1)); 
yyval := 
yy.value_stack(yy.tos-2); 

when 116 => -- #line 461
 
yyval := 
yy.value_stack(yy.tos-1); 

when 117 => -- #line 466
 Add_Selector_Filter (
yy.value_stack(yy.tos-1), 
yy.value_stack(yy.tos)); 
yyval := 
yy.value_stack(yy.tos-1); 

when 119 => -- #line 473
 Set_Selector (
yyval, SEL_ELEMENT, 
yy.value_stack(yy.tos)); 

when 120 => -- #line 476
 Set_Selector (
yyval, SEL_IDENT, 
yy.value_stack(yy.tos)); 

when 121 => -- #line 479
 Set_Selector (
yyval, SEL_CLASS, 
yy.value_stack(yy.tos)); 

when 124 => -- #line 486
 Set_Selector (
yyval, SEL_NOT, 
yy.value_stack(yy.tos-2)); 

when 129 => -- #line 501
 
yyval := 
yy.value_stack(yy.tos); 

when 130 => -- #line 506
 
yyval := 
yy.value_stack(yy.tos); 

when 137 => -- #line 525
 Set_Selector (
yyval, SEL_HAS_ATTRIBUTE, 
yy.value_stack(yy.tos-2)); 

when 138 => -- #line 528
 Set_Selector (
yyval, 
yy.value_stack(yy.tos-4).Sel, 
yy.value_stack(yy.tos-6), 
yy.value_stack(yy.tos-2)); 

when 139 => -- #line 531
 Set_Selector (
yyval, 
yy.value_stack(yy.tos-4).Sel, 
yy.value_stack(yy.tos-6), 
yy.value_stack(yy.tos-2)); 

when 140 => -- #line 534
 Error (
yy.value_stack(yy.tos).Line, 
yy.value_stack(yy.tos).column, "Invalid attribute definition."); 

when 141 => -- #line 539
 Set_Selector_Type (
yyval, SEL_EQ_ATTRIBUTE, yylineno, yylinecol); 

when 142 => -- #line 542
 Set_Selector_Type (
yyval, SEL_CONTAIN_ATTRIBUTE, yylineno, yylinecol); 

when 143 => -- #line 545
 Set_Selector_Type (
yyval, SEL_ORMATCH_ATTRIBUTE, yylineno, yylinecol); 

when 144 => -- #line 548
 Set_Selector_Type (
yyval, SEL_STARTS_ATTRIBUTE, yylineno, yylinecol); 

when 145 => -- #line 551
 Set_Selector_Type (
yyval, SEL_ENDS_ATTRIBUTE, yylineno, yylinecol); 

when 146 => -- #line 554
 Set_Selector_Type (
yyval, SEL_MATCH_ATTRIBUTE, yylineno, yylinecol); 

when 147 => -- #line 559
 Set_Selector (
yyval, SEL_PSEUDO_ELEMENT, 
yy.value_stack(yy.tos)); 

when 148 => -- #line 562
 Set_Selector (
yyval, SEL_PSEUDO_CLASS, 
yy.value_stack(yy.tos)); 

when 149 => -- #line 565
 Set_Selector (
yyval, SEL_FUNCTION, 
yy.value_stack(yy.tos-3)); 

when 152 => -- #line 576
 
yyval := 
yy.value_stack(yy.tos); 

when 153 => -- #line 581
 
yyval := 
yy.value_stack(yy.tos); 

when 154 => -- #line 584
 
yyval := 
yy.value_stack(yy.tos-4); 

when 155 => -- #line 587
 
yyval := 
yy.value_stack(yy.tos-1); 

when 156 => -- #line 592
 Append_Property (Current_Rule, Current_Media, Document, 
yy.value_stack(yy.tos-1)); 

when 157 => -- #line 595
 Append_Property (Current_Rule, Current_Media, Document, 
yy.value_stack(yy.tos));
         Error (
yy.value_stack(yy.tos-3).Line, 
yy.value_stack(yy.tos-3).Column, "Invalid property"); yyerrok; 

when 158 => -- #line 599
 
yyval := 
yy.value_stack(yy.tos-2); Error (
yy.value_stack(yy.tos-1).Line, 
yy.value_stack(yy.tos-1).Column, "Invalid property (2)"); yyerrok; 

when 159 => -- #line 602
 Append_Property (Current_Rule, Current_Media, Document, 
yy.value_stack(yy.tos-1)); 

when 162 => -- #line 613
 Set_Property (
yyval, 
yy.value_stack(yy.tos-4), 
yy.value_stack(yy.tos-1), True); 

when 163 => -- #line 616
 Set_Property (
yyval, 
yy.value_stack(yy.tos-3), 
yy.value_stack(yy.tos), False); 

when 164 => -- #line 619
 Error (
yy.value_stack(yy.tos).Line, 
yy.value_stack(yy.tos).Column, "Missing ''' or '""' at end of string");
          Set_Property (
yyval, 
yy.value_stack(yy.tos-3), EMPTY, False);
          yyclearin;
        

when 165 => -- #line 625
 Error (
yy.value_stack(yy.tos).Line, 
yy.value_stack(yy.tos).Column, "Invalid property value: " & YYText);
          Set_Property (
yyval, 
yy.value_stack(yy.tos-2), 
yy.value_stack(yy.tos-2), False);
          yyclearin;
        

when 166 => -- #line 631
 Error (
yy.value_stack(yy.tos-1).Line, 
yy.value_stack(yy.tos-1).Column, "Missing ':' after property name");
          Set_Property (
yyval, 
yy.value_stack(yy.tos-1), EMPTY, False);
          yyclearin;
        

when 167 => -- #line 637
 Error (yylval.Line, yylval.Column, "Invalid property name"); 
yyval := EMPTY; 

when 168 => -- #line 642
 
yyval := 
yy.value_stack(yy.tos-1); 

when 169 => -- #line 645
 Warning (
yy.value_stack(yy.tos-1).Line, 
yy.value_stack(yy.tos-1).Column, "IE7 '*' symbol hack is used"); 
yyval := 
yy.value_stack(yy.tos-1); 

when 171 => -- #line 654
 CSS.Parser.Set_Function (
yyval, Document, 
yy.value_stack(yy.tos-4), 
yy.value_stack(yy.tos-2)); 

when 172 => -- #line 657
 CSS.Parser.Set_Function (
yyval, Document, 
yy.value_stack(yy.tos-3), 
yy.value_stack(yy.tos-1)); 

when 173 => -- #line 660
 Error (
yy.value_stack(yy.tos-3).Line, 
yy.value_stack(yy.tos-3).Column, "Invalid function parameter"); 

when 174 => -- #line 665
 CSS.Parser.Set_Expr (
yyval, 
yy.value_stack(yy.tos-3), 
yy.value_stack(yy.tos)); 

when 175 => -- #line 668
 CSS.Parser.Set_Expr (
yyval, 
yy.value_stack(yy.tos-1), 
yy.value_stack(yy.tos)); 

when 176 => -- #line 671
 
yyval := 
yy.value_stack(yy.tos); 

when 177 => -- #line 676
 CSS.Parser.Set_Expr (
yyval, 
yy.value_stack(yy.tos-3), 
yy.value_stack(yy.tos)); 

when 178 => -- #line 679
 CSS.Parser.Set_Expr (
yyval, 
yy.value_stack(yy.tos-3), 
yy.value_stack(yy.tos)); 

when 179 => -- #line 682
 CSS.Parser.Set_Expr (
yyval, 
yy.value_stack(yy.tos-1), 
yy.value_stack(yy.tos)); 

when 180 => -- #line 685
 
yyval := 
yy.value_stack(yy.tos); 

when 181 => -- #line 688
 
yyval := 
yy.value_stack(yy.tos-1); --  CSS.Parser.Set_Parameter ($$, Document, $1, $5);
        

when 182 => -- #line 694
 CSS.Parser.Set_Expr (
yyval, 
yy.value_stack(yy.tos-2), 
yy.value_stack(yy.tos)); 

when 183 => -- #line 697
 CSS.Parser.Set_Expr (
yyval, 
yy.value_stack(yy.tos-1), 
yy.value_stack(yy.tos)); 

when 185 => -- #line 704
 CSS.Parser.Set_Value (
yyval, Document, 
yy.value_stack(yy.tos)); 

when 186 => -- #line 707
 CSS.Parser.Set_Value (
yyval, Document, 
yy.value_stack(yy.tos)); 

when 187 => -- #line 710
 CSS.Parser.Set_Value (
yyval, Document, 
yy.value_stack(yy.tos)); 

when 188 => -- #line 713
 CSS.Parser.Set_Value (
yyval, Document, 
yy.value_stack(yy.tos-1)); 

when 189 => -- #line 716
 CSS.Parser.Set_Value (
yyval, Document, 
yy.value_stack(yy.tos-1)); 

when 190 => -- #line 719
 CSS.Parser.Set_Value (
yyval, Document, 
yy.value_stack(yy.tos-1)); 

when 191 => -- #line 722
 CSS.Parser.Set_Value (
yyval, Document, 
yy.value_stack(yy.tos)); 

when 192 => -- #line 725
 
yyval := 
yy.value_stack(yy.tos); 

when 193 => -- #line 728
 Error (
yy.value_stack(yy.tos).Line, 
yy.value_stack(yy.tos).Column, "Invalid url()"); 
yyval := EMPTY; 

when 194 => -- #line 733
 
yyval := 
yy.value_stack(yy.tos-1); 

when 195 => -- #line 736
 
yyval := 
yy.value_stack(yy.tos-1); 

when 196 => -- #line 739
 
yyval := 
yy.value_stack(yy.tos-1); 

when 197 => -- #line 742
 
yyval := 
yy.value_stack(yy.tos-1); 

when 198 => -- #line 745
 
yyval := 
yy.value_stack(yy.tos-1); 

when 199 => -- #line 748
 
yyval := 
yy.value_stack(yy.tos-1); 

when 200 => -- #line 751
 
yyval := 
yy.value_stack(yy.tos-1); 

when 201 => -- #line 754
 
yyval := 
yy.value_stack(yy.tos-1); 

when 202 => -- #line 759
 Set_Color (
yyval, 
yy.value_stack(yy.tos-1)); 

                    when others => null;
                end case;


            -- Pop RHS states and goto next state
            yy.tos      := yy.tos - rule_length(yy.rule_id) + 1;
            if yy.tos > yy.stack_size then
                text_io.put_line(" Stack size exceeded on state_stack");
                raise yy_Tokens.syntax_error;
            end if;
            yy.state_stack(yy.tos) := goto_state(yy.state_stack(yy.tos-1) ,
                                 get_lhs_rule(yy.rule_id));

              yy.value_stack(yy.tos) := yyval;

            if yy.debug then
                reduce_debug(yy.rule_id,
                    goto_state(yy.state_stack(yy.tos - 1),
                               get_lhs_rule(yy.rule_id)));
            end if;

        end if;


    end loop;


end yyparse;

end CSS.Parser.Parser;
